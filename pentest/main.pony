use "collections"

primitive GridN
  fun apply(sx: F64, sy: F64, dim: USize, factor: F64): PathCommands =>
    let pcs = PathCommands
    for i in Range[F64](0, dim.f64() + 1) do
      pcs
        .>command(PathMove.abs(sx, sy + (i * factor)))
        .>command(PathLine.abs(sx + (dim.f64() * factor), sy + (i * factor)))
        .>command(PathMove.abs(sx + (i * factor), sy))
        .>command(PathLine.abs(sx + (i * factor), sy + (dim.f64() * factor)))
    end
    pcs

actor Main
  new create(env: Env) =>
    let svg = SVG.svg()

    // draw 3x3 grids with 5, 10, 20 pixel spacings
    let grids = PathCommands

    for (f, x, y) in [as (F64, F64, F64):
      (5, 20, 20)
      (10, 20, 60)
      (20, 20, 110)].values()
    do
      grids.commands(GridN(x, y, 3, f))
    end

    svg.c(SVG.path(grids))

    // circle r = 40
    svg.c(SVG.circle(120, 60, 40))

    // square 40x40

    let square = PathCommands
      .>command(PathMove.abs(160, 100))
      .>command(PathLine.abs(240, 100))
      .>command(PathLine.abs(240, 180))
      .>command(PathLine.abs(160, 180))
      .>command(PathLine.abs(160, 100))

    svg.c(SVG.path(square))

    // lines

    let lines = PathCommands

    for x in Range[F64](1, 16) do
      let xx = x + 16
      lines
        .>command(PathMove.abs(260, 20 + (x * 10)))
        .>command(PathLine.abs(260 + x, 20 + (x * 10)))
        .>command(PathMove.abs(290, 20 + (x * 10)))
        .>command(PathLine.abs(290 + xx, 20 + (x * 10)))
    end

    for x in Range[F64](16, 31) do
      lines
    end

    svg.c(SVG.path(lines))

    env.out.print(svg.render())
